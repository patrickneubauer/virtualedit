/*
 * generated by Xtext 2.10.0
 */
package at.ac.tuwien.big.simpleaspect.serializer;

import at.ac.tuwien.big.simpleaspect.services.SimpleAspectGrammarAccess;
import at.ac.tuwien.big.simpleaspect.simpleAspect.Advice;
import at.ac.tuwien.big.simpleaspect.simpleAspect.Aspect;
import at.ac.tuwien.big.simpleaspect.simpleAspect.AspectExpression;
import at.ac.tuwien.big.simpleaspect.simpleAspect.Assignment;
import at.ac.tuwien.big.simpleaspect.simpleAspect.BinaryPointcutCondition;
import at.ac.tuwien.big.simpleaspect.simpleAspect.BooleanExpression;
import at.ac.tuwien.big.simpleaspect.simpleAspect.ConstructorCall;
import at.ac.tuwien.big.simpleaspect.simpleAspect.ForInStatement;
import at.ac.tuwien.big.simpleaspect.simpleAspect.ForStatement;
import at.ac.tuwien.big.simpleaspect.simpleAspect.ForeignAttribute;
import at.ac.tuwien.big.simpleaspect.simpleAspect.IfStatement;
import at.ac.tuwien.big.simpleaspect.simpleAspect.IntegerExpression;
import at.ac.tuwien.big.simpleaspect.simpleAspect.Method;
import at.ac.tuwien.big.simpleaspect.simpleAspect.MethodBlock;
import at.ac.tuwien.big.simpleaspect.simpleAspect.MethodCall;
import at.ac.tuwien.big.simpleaspect.simpleAspect.NullExpression;
import at.ac.tuwien.big.simpleaspect.simpleAspect.ParanthesisOrBinaryExpression;
import at.ac.tuwien.big.simpleaspect.simpleAspect.Pointcut;
import at.ac.tuwien.big.simpleaspect.simpleAspect.PointcutMethodFilter;
import at.ac.tuwien.big.simpleaspect.simpleAspect.PointcutRef;
import at.ac.tuwien.big.simpleaspect.simpleAspect.PointcutTypeFilter;
import at.ac.tuwien.big.simpleaspect.simpleAspect.ReturnStatement;
import at.ac.tuwien.big.simpleaspect.simpleAspect.SimpleAspectPackage;
import at.ac.tuwien.big.simpleaspect.simpleAspect.SimplePointcutCondition;
import at.ac.tuwien.big.simpleaspect.simpleAspect.StringExpression;
import at.ac.tuwien.big.simpleaspect.simpleAspect.Type;
import at.ac.tuwien.big.simpleaspect.simpleAspect.UnaryExpression;
import at.ac.tuwien.big.simpleaspect.simpleAspect.UnaryPointcutCondition;
import at.ac.tuwien.big.simpleaspect.simpleAspect.VariableDeclaration;
import at.ac.tuwien.big.simpleaspect.simpleAspect.VariableExpression;
import at.ac.tuwien.big.simpleaspect.simpleAspect.WhileStatement;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class SimpleAspectSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SimpleAspectGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SimpleAspectPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SimpleAspectPackage.ADVICE:
				sequence_Advice(context, (Advice) semanticObject); 
				return; 
			case SimpleAspectPackage.ASPECT:
				sequence_Aspect(context, (Aspect) semanticObject); 
				return; 
			case SimpleAspectPackage.ASPECT_EXPRESSION:
				sequence_AspectExpression(context, (AspectExpression) semanticObject); 
				return; 
			case SimpleAspectPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case SimpleAspectPackage.BINARY_POINTCUT_CONDITION:
				sequence_BinaryPointcutCondition(context, (BinaryPointcutCondition) semanticObject); 
				return; 
			case SimpleAspectPackage.BOOLEAN_EXPRESSION:
				sequence_BooleanExpression(context, (BooleanExpression) semanticObject); 
				return; 
			case SimpleAspectPackage.CONSTRUCTOR_CALL:
				sequence_ConstructorCall(context, (ConstructorCall) semanticObject); 
				return; 
			case SimpleAspectPackage.FOR_IN_STATEMENT:
				sequence_ForInStatement(context, (ForInStatement) semanticObject); 
				return; 
			case SimpleAspectPackage.FOR_STATEMENT:
				sequence_ForStatement(context, (ForStatement) semanticObject); 
				return; 
			case SimpleAspectPackage.FOREIGN_ATTRIBUTE:
				sequence_ForeignAttribute(context, (ForeignAttribute) semanticObject); 
				return; 
			case SimpleAspectPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case SimpleAspectPackage.INTEGER_EXPRESSION:
				sequence_IntegerExpression(context, (IntegerExpression) semanticObject); 
				return; 
			case SimpleAspectPackage.METHOD:
				sequence_Method(context, (Method) semanticObject); 
				return; 
			case SimpleAspectPackage.METHOD_BLOCK:
				sequence_MethodBlock(context, (MethodBlock) semanticObject); 
				return; 
			case SimpleAspectPackage.METHOD_CALL:
				sequence_MethodCall(context, (MethodCall) semanticObject); 
				return; 
			case SimpleAspectPackage.NULL_EXPRESSION:
				sequence_NullExpression(context, (NullExpression) semanticObject); 
				return; 
			case SimpleAspectPackage.PARAMETER:
				sequence_Parameter(context, (at.ac.tuwien.big.simpleaspect.simpleAspect.Parameter) semanticObject); 
				return; 
			case SimpleAspectPackage.PARANTHESIS_OR_BINARY_EXPRESSION:
				sequence_ParanthesisOrBinaryExpression(context, (ParanthesisOrBinaryExpression) semanticObject); 
				return; 
			case SimpleAspectPackage.POINTCUT:
				sequence_Pointcut(context, (Pointcut) semanticObject); 
				return; 
			case SimpleAspectPackage.POINTCUT_METHOD_FILTER:
				sequence_PointcutMethodFilter(context, (PointcutMethodFilter) semanticObject); 
				return; 
			case SimpleAspectPackage.POINTCUT_REF:
				sequence_PointcutRef(context, (PointcutRef) semanticObject); 
				return; 
			case SimpleAspectPackage.POINTCUT_TYPE_FILTER:
				sequence_PointcutTypeFilter(context, (PointcutTypeFilter) semanticObject); 
				return; 
			case SimpleAspectPackage.RETURN_STATEMENT:
				sequence_ReturnStatement(context, (ReturnStatement) semanticObject); 
				return; 
			case SimpleAspectPackage.SIMPLE_POINTCUT_CONDITION:
				sequence_SimplePointcutCondition(context, (SimplePointcutCondition) semanticObject); 
				return; 
			case SimpleAspectPackage.STRING_EXPRESSION:
				sequence_StringExpression(context, (StringExpression) semanticObject); 
				return; 
			case SimpleAspectPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case SimpleAspectPackage.UNARY_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryExpression) semanticObject); 
				return; 
			case SimpleAspectPackage.UNARY_POINTCUT_CONDITION:
				sequence_UnaryPointcutCondition(context, (UnaryPointcutCondition) semanticObject); 
				return; 
			case SimpleAspectPackage.VARIABLE_DECLARATION:
				if (rule == grammarAccess.getSimpleStatementRule()
						|| rule == grammarAccess.getSimpleVariableDeclarationRule()) {
					sequence_SimpleVariableDeclaration(context, (VariableDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()
						|| rule == grammarAccess.getVariableDeclarationRule()) {
					sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
					return; 
				}
				else break;
			case SimpleAspectPackage.VARIABLE_EXPRESSION:
				sequence_VariableExpression(context, (VariableExpression) semanticObject); 
				return; 
			case SimpleAspectPackage.WHILE_STATEMENT:
				sequence_WhileStatement(context, (WhileStatement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Advice returns Advice
	 *
	 * Constraint:
	 *     (
	 *         (type='before' | type='after' | type='around') 
	 *         (parameter+=Parameter parameter+=Parameter*)? 
	 *         (pointcut=PointcutRef | pointcut=Pointcut) 
	 *         code=MethodBlock
	 *     )
	 */
	protected void sequence_Advice(ISerializationContext context, Advice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GenericExpression returns AspectExpression
	 *     ConstantExpression returns AspectExpression
	 *     AspectExpression returns AspectExpression
	 *
	 * Constraint:
	 *     (value='METHOD_NAME' | value='CLASS_NAME')
	 */
	protected void sequence_AspectExpression(ISerializationContext context, AspectExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Aspect returns Aspect
	 *
	 * Constraint:
	 *     (name=ID (attributes+=ForeignAttribute | methods+=Method | pointcuts+=Pointcut | advices+=Advice)*)
	 */
	protected void sequence_Aspect(ISerializationContext context, Aspect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement returns Assignment
	 *     Statement returns Assignment
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (parameter=[Parameter|QualifiedName] expression=GenericExpression)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimpleAspectPackage.Literals.ASSIGNMENT__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleAspectPackage.Literals.ASSIGNMENT__PARAMETER));
			if (transientValues.isValueTransient(semanticObject, SimpleAspectPackage.Literals.ASSIGNMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleAspectPackage.Literals.ASSIGNMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getParameterParameterQualifiedNameParserRuleCall_0_0_1(), semanticObject.getParameter());
		feeder.accept(grammarAccess.getAssignmentAccess().getExpressionGenericExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PointcutCondition returns BinaryPointcutCondition
	 *     BinaryPointcutCondition returns BinaryPointcutCondition
	 *
	 * Constraint:
	 *     (first=PointcutCondition (type='||' | type='&&') second=PointcutCondition)
	 */
	protected void sequence_BinaryPointcutCondition(ISerializationContext context, BinaryPointcutCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GenericExpression returns BooleanExpression
	 *     ConstantExpression returns BooleanExpression
	 *     BooleanExpression returns BooleanExpression
	 *
	 * Constraint:
	 *     value?='true'?
	 */
	protected void sequence_BooleanExpression(ISerializationContext context, BooleanExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GenericExpression returns ConstructorCall
	 *     ConstructorCall returns ConstructorCall
	 *
	 * Constraint:
	 *     (type=Type (parameter+=ConstantExpression parameter+=ConstantExpression*)?)
	 */
	protected void sequence_ConstructorCall(ISerializationContext context, ConstructorCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ForInStatement
	 *     ForInStatement returns ForInStatement
	 *
	 * Constraint:
	 *     (subparameter=Parameter expression=GenericExpression body=Statement)
	 */
	protected void sequence_ForInStatement(ISerializationContext context, ForInStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimpleAspectPackage.Literals.FOR_IN_STATEMENT__SUBPARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleAspectPackage.Literals.FOR_IN_STATEMENT__SUBPARAMETER));
			if (transientValues.isValueTransient(semanticObject, SimpleAspectPackage.Literals.FOR_IN_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleAspectPackage.Literals.FOR_IN_STATEMENT__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, SimpleAspectPackage.Literals.FOR_IN_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleAspectPackage.Literals.FOR_IN_STATEMENT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForInStatementAccess().getSubparameterParameterParserRuleCall_2_0(), semanticObject.getSubparameter());
		feeder.accept(grammarAccess.getForInStatementAccess().getExpressionGenericExpressionParserRuleCall_4_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getForInStatementAccess().getBodyStatementParserRuleCall_6_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ForStatement
	 *     ForStatement returns ForStatement
	 *
	 * Constraint:
	 *     (init=SimpleStatement? condition=GenericExpression continuation=SimpleStatement body=Statement)
	 */
	protected void sequence_ForStatement(ISerializationContext context, ForStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForeignAttribute returns ForeignAttribute
	 *
	 * Constraint:
	 *     (type=Type inType=QualifiedName? name=ID expression=GenericExpression?)
	 */
	protected void sequence_ForeignAttribute(ISerializationContext context, ForeignAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfStatement
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (condition=ParanthesisOrBinaryExpression then=MethodBlock else=MethodBlock?)
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GenericExpression returns IntegerExpression
	 *     ConstantExpression returns IntegerExpression
	 *     IntegerExpression returns IntegerExpression
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_IntegerExpression(ISerializationContext context, IntegerExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimpleAspectPackage.Literals.INTEGER_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleAspectPackage.Literals.INTEGER_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerExpressionAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MethodBlock returns MethodBlock
	 *     Statement returns MethodBlock
	 *
	 * Constraint:
	 *     (generated?='pointcutblock'? statements+=Statement*)
	 */
	protected void sequence_MethodBlock(ISerializationContext context, MethodBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MethodCall
	 *     MethodCall returns MethodCall
	 *     GenericExpression returns MethodCall
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (
	 *                 (object=[ForeignAttribute|ID] | thisObject?='this')? 
	 *                 (
	 *                     method=[Method|ID] | 
	 *                     methodName='equals' | 
	 *                     methodName='hashCode' | 
	 *                     methodName='add' | 
	 *                     methodName='remove' | 
	 *                     methodName='clear' | 
	 *                     methodName='logp'
	 *                 )
	 *             ) | 
	 *             methodName='System.out.println'
	 *         ) 
	 *         (parameter+=GenericExpression parameter+=GenericExpression*)?
	 *     )
	 */
	protected void sequence_MethodCall(ISerializationContext context, MethodCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Method returns Method
	 *
	 * Constraint:
	 *     (static?='static'? returnType=Type name=ID (parameter+=Parameter parameter+=Parameter*)? content=MethodBlock)
	 */
	protected void sequence_Method(ISerializationContext context, Method semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GenericExpression returns NullExpression
	 *     ConstantExpression returns NullExpression
	 *     NullExpression returns NullExpression
	 *
	 * Constraint:
	 *     {NullExpression}
	 */
	protected void sequence_NullExpression(ISerializationContext context, NullExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (type=Type name=ID)
	 */
	protected void sequence_Parameter(ISerializationContext context, at.ac.tuwien.big.simpleaspect.simpleAspect.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimpleAspectPackage.Literals.PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleAspectPackage.Literals.PARAMETER__TYPE));
			if (transientValues.isValueTransient(semanticObject, SimpleAspectPackage.Literals.PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleAspectPackage.Literals.PARAMETER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getTypeTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GenericExpression returns ParanthesisOrBinaryExpression
	 *     ParanthesisOrBinaryExpression returns ParanthesisOrBinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         source=GenericExpression 
	 *         (
	 *             (
	 *                 type='||' | 
	 *                 type='&&' | 
	 *                 type='&' | 
	 *                 type='+' | 
	 *                 type='-' | 
	 *                 type='*' | 
	 *                 type='/' | 
	 *                 type='==' | 
	 *                 type='!=' | 
	 *                 type='<' | 
	 *                 type='<=' | 
	 *                 type='>' | 
	 *                 type='>='
	 *             ) 
	 *             argument=GenericExpression
	 *         )?
	 *     )
	 */
	protected void sequence_ParanthesisOrBinaryExpression(ISerializationContext context, ParanthesisOrBinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PointcutMethodFilter returns PointcutMethodFilter
	 *
	 * Constraint:
	 *     (
	 *         isPublic?='public'? 
	 *         isPrivate?='private'? 
	 *         isStatic?='static'? 
	 *         (anyReturn?='*' | returnType=Type) 
	 *         (anyClass?='*' | classType=QualifiedName) 
	 *         (anyMethod?='*' | methodName=ID) 
	 *         (anyParameter?='..' | (parameter+=Type parameter+=Type*))?
	 *     )
	 */
	protected void sequence_PointcutMethodFilter(ISerializationContext context, PointcutMethodFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PointcutRef returns PointcutRef
	 *
	 * Constraint:
	 *     (pointcut=[Pointcut|ID] (parameterValue+=VariableExpression parameterValue+=VariableExpression*)?)
	 */
	protected void sequence_PointcutRef(ISerializationContext context, PointcutRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PointcutTypeFilter returns PointcutTypeFilter
	 *
	 * Constraint:
	 *     classType=QualifiedName
	 */
	protected void sequence_PointcutTypeFilter(ISerializationContext context, PointcutTypeFilter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimpleAspectPackage.Literals.POINTCUT_TYPE_FILTER__CLASS_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleAspectPackage.Literals.POINTCUT_TYPE_FILTER__CLASS_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointcutTypeFilterAccess().getClassTypeQualifiedNameParserRuleCall_1_0(), semanticObject.getClassType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pointcut returns Pointcut
	 *
	 * Constraint:
	 *     (name=ID (parameter+=Parameter parameter+=Parameter*)? condition=PointcutCondition)
	 */
	protected void sequence_Pointcut(ISerializationContext context, Pointcut semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ReturnStatement
	 *     ReturnStatement returns ReturnStatement
	 *
	 * Constraint:
	 *     expression=GenericExpression
	 */
	protected void sequence_ReturnStatement(ISerializationContext context, ReturnStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimpleAspectPackage.Literals.RETURN_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleAspectPackage.Literals.RETURN_STATEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReturnStatementAccess().getExpressionGenericExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PointcutCondition returns SimplePointcutCondition
	 *     SimplePointcutCondition returns SimplePointcutCondition
	 *
	 * Constraint:
	 *     (((type='call' | type='execution') condition=PointcutMethodFilter) | ((type='within' | type='handler') condition=PointcutTypeFilter))
	 */
	protected void sequence_SimplePointcutCondition(ISerializationContext context, SimplePointcutCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement returns VariableDeclaration
	 *     SimpleVariableDeclaration returns VariableDeclaration
	 *
	 * Constraint:
	 *     (parameter=Parameter expression=GenericExpression)
	 */
	protected void sequence_SimpleVariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimpleAspectPackage.Literals.VARIABLE_DECLARATION__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleAspectPackage.Literals.VARIABLE_DECLARATION__PARAMETER));
			if (transientValues.isValueTransient(semanticObject, SimpleAspectPackage.Literals.VARIABLE_DECLARATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleAspectPackage.Literals.VARIABLE_DECLARATION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleVariableDeclarationAccess().getParameterParameterParserRuleCall_1_0(), semanticObject.getParameter());
		feeder.accept(grammarAccess.getSimpleVariableDeclarationAccess().getExpressionGenericExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GenericExpression returns StringExpression
	 *     ConstantExpression returns StringExpression
	 *     StringExpression returns StringExpression
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringExpression(ISerializationContext context, StringExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimpleAspectPackage.Literals.STRING_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleAspectPackage.Literals.STRING_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringExpressionAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *
	 * Constraint:
	 *     (
	 *         typeName='int' | 
	 *         typeName='double' | 
	 *         typeName='String' | 
	 *         typeName='boolean' | 
	 *         typeName='Object' | 
	 *         typeName='List' | 
	 *         typeName='ArrayList' | 
	 *         typeName='Logger' | 
	 *         typeRef=QualifiedName | 
	 *         isVoid?='void'
	 *     )
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GenericExpression returns UnaryExpression
	 *     UnaryExpression returns UnaryExpression
	 *
	 * Constraint:
	 *     (type='!' source=GenericExpression)
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, UnaryExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimpleAspectPackage.Literals.UNARY_EXPRESSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleAspectPackage.Literals.UNARY_EXPRESSION__TYPE));
			if (transientValues.isValueTransient(semanticObject, SimpleAspectPackage.Literals.UNARY_EXPRESSION__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleAspectPackage.Literals.UNARY_EXPRESSION__SOURCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getTypeExclamationMarkKeyword_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getSourceGenericExpressionParserRuleCall_1_0(), semanticObject.getSource());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PointcutCondition returns UnaryPointcutCondition
	 *     UnaryPointcutCondition returns UnaryPointcutCondition
	 *
	 * Constraint:
	 *     condition=PointcutCondition
	 */
	protected void sequence_UnaryPointcutCondition(ISerializationContext context, UnaryPointcutCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimpleAspectPackage.Literals.UNARY_POINTCUT_CONDITION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleAspectPackage.Literals.UNARY_POINTCUT_CONDITION__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryPointcutConditionAccess().getConditionPointcutConditionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns VariableDeclaration
	 *     VariableDeclaration returns VariableDeclaration
	 *
	 * Constraint:
	 *     (parameter=Parameter expression=GenericExpression)
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimpleAspectPackage.Literals.VARIABLE_DECLARATION__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleAspectPackage.Literals.VARIABLE_DECLARATION__PARAMETER));
			if (transientValues.isValueTransient(semanticObject, SimpleAspectPackage.Literals.VARIABLE_DECLARATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleAspectPackage.Literals.VARIABLE_DECLARATION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getParameterParameterParserRuleCall_0_0(), semanticObject.getParameter());
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getExpressionGenericExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GenericExpression returns VariableExpression
	 *     VariableExpression returns VariableExpression
	 *
	 * Constraint:
	 *     variable=[Parameter|QualifiedName]
	 */
	protected void sequence_VariableExpression(ISerializationContext context, VariableExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimpleAspectPackage.Literals.VARIABLE_EXPRESSION__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleAspectPackage.Literals.VARIABLE_EXPRESSION__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableExpressionAccess().getVariableParameterQualifiedNameParserRuleCall_0_1(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns WhileStatement
	 *     WhileStatement returns WhileStatement
	 *
	 * Constraint:
	 *     (condition=ParanthesisOrBinaryExpression body=Statement)
	 */
	protected void sequence_WhileStatement(ISerializationContext context, WhileStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimpleAspectPackage.Literals.WHILE_STATEMENT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleAspectPackage.Literals.WHILE_STATEMENT__CONDITION));
			if (transientValues.isValueTransient(semanticObject, SimpleAspectPackage.Literals.WHILE_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleAspectPackage.Literals.WHILE_STATEMENT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileStatementAccess().getConditionParanthesisOrBinaryExpressionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getWhileStatementAccess().getBodyStatementParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
}
