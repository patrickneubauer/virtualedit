/*
 * generated by Xtext 2.10.0
 */
package at.ac.tuwien.big.serializer;

import at.ac.tuwien.big.services.SimplejavaGrammarAccess;
import at.ac.tuwien.big.simplejava.Assignment;
import at.ac.tuwien.big.simplejava.Attribute;
import at.ac.tuwien.big.simplejava.BooleanExpression;
import at.ac.tuwien.big.simplejava.ClassDeclaration;
import at.ac.tuwien.big.simplejava.ConstructorCall;
import at.ac.tuwien.big.simplejava.ForInStatement;
import at.ac.tuwien.big.simplejava.ForStatement;
import at.ac.tuwien.big.simplejava.IfStatement;
import at.ac.tuwien.big.simplejava.Import;
import at.ac.tuwien.big.simplejava.IntegerExpression;
import at.ac.tuwien.big.simplejava.Method;
import at.ac.tuwien.big.simplejava.MethodBlock;
import at.ac.tuwien.big.simplejava.MethodCall;
import at.ac.tuwien.big.simplejava.NullExpression;
import at.ac.tuwien.big.simplejava.PackageDeclaration;
import at.ac.tuwien.big.simplejava.ParanthesisOrBinaryExpression;
import at.ac.tuwien.big.simplejava.ReturnStatement;
import at.ac.tuwien.big.simplejava.SimpleJava;
import at.ac.tuwien.big.simplejava.SimpleParameter;
import at.ac.tuwien.big.simplejava.SimplejavaPackage;
import at.ac.tuwien.big.simplejava.StringExpression;
import at.ac.tuwien.big.simplejava.Type;
import at.ac.tuwien.big.simplejava.UnaryExpression;
import at.ac.tuwien.big.simplejava.VariableDeclaration;
import at.ac.tuwien.big.simplejava.VariableExpression;
import at.ac.tuwien.big.simplejava.WhileStatement;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class SimplejavaSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SimplejavaGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SimplejavaPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SimplejavaPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case SimplejavaPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case SimplejavaPackage.BOOLEAN_EXPRESSION:
				sequence_BooleanExpression(context, (BooleanExpression) semanticObject); 
				return; 
			case SimplejavaPackage.CLASS_DECLARATION:
				sequence_ClassDeclaration(context, (ClassDeclaration) semanticObject); 
				return; 
			case SimplejavaPackage.CONSTRUCTOR_CALL:
				sequence_ConstructorCall(context, (ConstructorCall) semanticObject); 
				return; 
			case SimplejavaPackage.FOR_IN_STATEMENT:
				sequence_ForInStatement(context, (ForInStatement) semanticObject); 
				return; 
			case SimplejavaPackage.FOR_STATEMENT:
				sequence_ForStatement(context, (ForStatement) semanticObject); 
				return; 
			case SimplejavaPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case SimplejavaPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case SimplejavaPackage.INTEGER_EXPRESSION:
				sequence_IntegerExpression(context, (IntegerExpression) semanticObject); 
				return; 
			case SimplejavaPackage.METHOD:
				sequence_Method(context, (Method) semanticObject); 
				return; 
			case SimplejavaPackage.METHOD_BLOCK:
				sequence_MethodBlock(context, (MethodBlock) semanticObject); 
				return; 
			case SimplejavaPackage.METHOD_CALL:
				sequence_MethodCall(context, (MethodCall) semanticObject); 
				return; 
			case SimplejavaPackage.NULL_EXPRESSION:
				sequence_NullExpression(context, (NullExpression) semanticObject); 
				return; 
			case SimplejavaPackage.PACKAGE_DECLARATION:
				sequence_PackageDeclaration(context, (PackageDeclaration) semanticObject); 
				return; 
			case SimplejavaPackage.PARANTHESIS_OR_BINARY_EXPRESSION:
				sequence_ParanthesisOrBinaryExpression(context, (ParanthesisOrBinaryExpression) semanticObject); 
				return; 
			case SimplejavaPackage.RETURN_STATEMENT:
				sequence_ReturnStatement(context, (ReturnStatement) semanticObject); 
				return; 
			case SimplejavaPackage.SIMPLE_JAVA:
				sequence_SimpleJava(context, (SimpleJava) semanticObject); 
				return; 
			case SimplejavaPackage.SIMPLE_PARAMETER:
				sequence_SimpleParameter(context, (SimpleParameter) semanticObject); 
				return; 
			case SimplejavaPackage.STRING_EXPRESSION:
				sequence_StringExpression(context, (StringExpression) semanticObject); 
				return; 
			case SimplejavaPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case SimplejavaPackage.UNARY_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryExpression) semanticObject); 
				return; 
			case SimplejavaPackage.VARIABLE_DECLARATION:
				if (rule == grammarAccess.getSimpleStatementRule()
						|| rule == grammarAccess.getSimpleVariableDeclarationRule()) {
					sequence_SimpleVariableDeclaration(context, (VariableDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()
						|| rule == grammarAccess.getVariableDeclarationRule()) {
					sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
					return; 
				}
				else break;
			case SimplejavaPackage.VARIABLE_EXPRESSION:
				sequence_VariableExpression(context, (VariableExpression) semanticObject); 
				return; 
			case SimplejavaPackage.WHILE_STATEMENT:
				sequence_WhileStatement(context, (WhileStatement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     SimpleStatement returns Assignment
	 *     Statement returns Assignment
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (parameter=[Parameter|QualifiedName] expression=GenericExpression)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimplejavaPackage.Literals.ASSIGNMENT__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplejavaPackage.Literals.ASSIGNMENT__PARAMETER));
			if (transientValues.isValueTransient(semanticObject, SimplejavaPackage.Literals.ASSIGNMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplejavaPackage.Literals.ASSIGNMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getParameterParameterQualifiedNameParserRuleCall_0_0_1(), semanticObject.getParameter());
		feeder.accept(grammarAccess.getAssignmentAccess().getExpressionGenericExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Attribute
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (type=Type name=ID expression=GenericExpression)
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimplejavaPackage.Literals.PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplejavaPackage.Literals.PARAMETER__TYPE));
			if (transientValues.isValueTransient(semanticObject, SimplejavaPackage.Literals.PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplejavaPackage.Literals.PARAMETER__NAME));
			if (transientValues.isValueTransient(semanticObject, SimplejavaPackage.Literals.ATTRIBUTE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplejavaPackage.Literals.ATTRIBUTE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeAccess().getTypeTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getAttributeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAttributeAccess().getExpressionGenericExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GenericExpression returns BooleanExpression
	 *     ConstantExpression returns BooleanExpression
	 *     BooleanExpression returns BooleanExpression
	 *
	 * Constraint:
	 *     value?='true'?
	 */
	protected void sequence_BooleanExpression(ISerializationContext context, BooleanExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassDeclaration returns ClassDeclaration
	 *
	 * Constraint:
	 *     (name=ID attribute+=Parameter* method+=Method*)
	 */
	protected void sequence_ClassDeclaration(ISerializationContext context, ClassDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstructorCall returns ConstructorCall
	 *     GenericExpression returns ConstructorCall
	 *
	 * Constraint:
	 *     (type=Type (parameter+=ConstantExpression parameter+=ConstantExpression*)?)
	 */
	protected void sequence_ConstructorCall(ISerializationContext context, ConstructorCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ForInStatement
	 *     ForInStatement returns ForInStatement
	 *
	 * Constraint:
	 *     (subparameter=SimpleParameter expression=GenericExpression body=Statement)
	 */
	protected void sequence_ForInStatement(ISerializationContext context, ForInStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimplejavaPackage.Literals.FOR_IN_STATEMENT__SUBPARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplejavaPackage.Literals.FOR_IN_STATEMENT__SUBPARAMETER));
			if (transientValues.isValueTransient(semanticObject, SimplejavaPackage.Literals.FOR_IN_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplejavaPackage.Literals.FOR_IN_STATEMENT__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, SimplejavaPackage.Literals.FOR_IN_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplejavaPackage.Literals.FOR_IN_STATEMENT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForInStatementAccess().getSubparameterSimpleParameterParserRuleCall_2_0(), semanticObject.getSubparameter());
		feeder.accept(grammarAccess.getForInStatementAccess().getExpressionGenericExpressionParserRuleCall_4_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getForInStatementAccess().getBodyStatementParserRuleCall_6_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ForStatement
	 *     ForStatement returns ForStatement
	 *
	 * Constraint:
	 *     (init=SimpleStatement? condition=GenericExpression continuation=SimpleStatement body=Statement)
	 */
	protected void sequence_ForStatement(ISerializationContext context, ForStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfStatement
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (condition=ParanthesisOrBinaryExpression then=MethodBlock else=MethodBlock?)
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     imported=QualifiedNameWithWildcard
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimplejavaPackage.Literals.IMPORT__IMPORTED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplejavaPackage.Literals.IMPORT__IMPORTED));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImported());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GenericExpression returns IntegerExpression
	 *     ConstantExpression returns IntegerExpression
	 *     IntegerExpression returns IntegerExpression
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_IntegerExpression(ISerializationContext context, IntegerExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimplejavaPackage.Literals.INTEGER_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplejavaPackage.Literals.INTEGER_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerExpressionAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MethodBlock returns MethodBlock
	 *     Statement returns MethodBlock
	 *
	 * Constraint:
	 *     (generated?='pointcutblock'? statements+=Statement*)
	 */
	protected void sequence_MethodBlock(ISerializationContext context, MethodBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MethodCall
	 *     MethodCall returns MethodCall
	 *     GenericExpression returns MethodCall
	 *
	 * Constraint:
	 *     (
	 *         (object=[Parameter|QualifiedName] | thisObject?='this')? 
	 *         (
	 *             method=[Method|ID] | 
	 *             methodName='equals' | 
	 *             methodName='hashCode' | 
	 *             methodName='add' | 
	 *             methodName='remove' | 
	 *             methodName='clear' | 
	 *             methodName='logp' | 
	 *             methodName='System.out.println'
	 *         ) 
	 *         (parameter+=GenericExpression parameter+=GenericExpression*)?
	 *     )
	 */
	protected void sequence_MethodCall(ISerializationContext context, MethodCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Method returns Method
	 *
	 * Constraint:
	 *     (static?='static'? returnType=Type name=ID? (parameter+=SimpleParameter parameter+=SimpleParameter*)? content=MethodBlock)
	 */
	protected void sequence_Method(ISerializationContext context, Method semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GenericExpression returns NullExpression
	 *     ConstantExpression returns NullExpression
	 *     NullExpression returns NullExpression
	 *
	 * Constraint:
	 *     {NullExpression}
	 */
	protected void sequence_NullExpression(ISerializationContext context, NullExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PackageDeclaration returns PackageDeclaration
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_PackageDeclaration(ISerializationContext context, PackageDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimplejavaPackage.Literals.PACKAGE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplejavaPackage.Literals.PACKAGE_DECLARATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPackageDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GenericExpression returns ParanthesisOrBinaryExpression
	 *     ParanthesisOrBinaryExpression returns ParanthesisOrBinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         source=GenericExpression 
	 *         (
	 *             (
	 *                 type='||' | 
	 *                 type='&&' | 
	 *                 type='&' | 
	 *                 type='+' | 
	 *                 type='-' | 
	 *                 type='*' | 
	 *                 type='/' | 
	 *                 type='==' | 
	 *                 type='!=' | 
	 *                 type='<' | 
	 *                 type='<=' | 
	 *                 type='>' | 
	 *                 type='>='
	 *             ) 
	 *             argument=GenericExpression
	 *         )?
	 *     )
	 */
	protected void sequence_ParanthesisOrBinaryExpression(ISerializationContext context, ParanthesisOrBinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ReturnStatement
	 *     ReturnStatement returns ReturnStatement
	 *
	 * Constraint:
	 *     expression=GenericExpression
	 */
	protected void sequence_ReturnStatement(ISerializationContext context, ReturnStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimplejavaPackage.Literals.RETURN_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplejavaPackage.Literals.RETURN_STATEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReturnStatementAccess().getExpressionGenericExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleJava returns SimpleJava
	 *
	 * Constraint:
	 *     (package=PackageDeclaration? imports+=Import* clazz=ClassDeclaration)
	 */
	protected void sequence_SimpleJava(ISerializationContext context, SimpleJava semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns SimpleParameter
	 *     SimpleParameter returns SimpleParameter
	 *
	 * Constraint:
	 *     (type=Type name=ID)
	 */
	protected void sequence_SimpleParameter(ISerializationContext context, SimpleParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimplejavaPackage.Literals.PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplejavaPackage.Literals.PARAMETER__TYPE));
			if (transientValues.isValueTransient(semanticObject, SimplejavaPackage.Literals.PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplejavaPackage.Literals.PARAMETER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleParameterAccess().getTypeTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getSimpleParameterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement returns VariableDeclaration
	 *     SimpleVariableDeclaration returns VariableDeclaration
	 *
	 * Constraint:
	 *     (parameter=SimpleParameter expression=GenericExpression)
	 */
	protected void sequence_SimpleVariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimplejavaPackage.Literals.VARIABLE_DECLARATION__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplejavaPackage.Literals.VARIABLE_DECLARATION__PARAMETER));
			if (transientValues.isValueTransient(semanticObject, SimplejavaPackage.Literals.VARIABLE_DECLARATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplejavaPackage.Literals.VARIABLE_DECLARATION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleVariableDeclarationAccess().getParameterSimpleParameterParserRuleCall_1_0(), semanticObject.getParameter());
		feeder.accept(grammarAccess.getSimpleVariableDeclarationAccess().getExpressionGenericExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GenericExpression returns StringExpression
	 *     ConstantExpression returns StringExpression
	 *     StringExpression returns StringExpression
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringExpression(ISerializationContext context, StringExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimplejavaPackage.Literals.STRING_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplejavaPackage.Literals.STRING_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringExpressionAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *
	 * Constraint:
	 *     (
	 *         typeName='int' | 
	 *         typeName='double' | 
	 *         typeName='String' | 
	 *         typeName='boolean' | 
	 *         typeName='Object' | 
	 *         typeName='List' | 
	 *         typeName='ArrayList' | 
	 *         typeName='Logger' | 
	 *         isVoid?='void' | 
	 *         typeRef=[ClassDeclaration|QualifiedName]
	 *     )
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GenericExpression returns UnaryExpression
	 *     UnaryExpression returns UnaryExpression
	 *
	 * Constraint:
	 *     (type='!' source=GenericExpression)
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, UnaryExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimplejavaPackage.Literals.UNARY_EXPRESSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplejavaPackage.Literals.UNARY_EXPRESSION__TYPE));
			if (transientValues.isValueTransient(semanticObject, SimplejavaPackage.Literals.UNARY_EXPRESSION__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplejavaPackage.Literals.UNARY_EXPRESSION__SOURCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getTypeExclamationMarkKeyword_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getSourceGenericExpressionParserRuleCall_1_0(), semanticObject.getSource());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns VariableDeclaration
	 *     VariableDeclaration returns VariableDeclaration
	 *
	 * Constraint:
	 *     (parameter=SimpleParameter expression=GenericExpression)
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimplejavaPackage.Literals.VARIABLE_DECLARATION__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplejavaPackage.Literals.VARIABLE_DECLARATION__PARAMETER));
			if (transientValues.isValueTransient(semanticObject, SimplejavaPackage.Literals.VARIABLE_DECLARATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplejavaPackage.Literals.VARIABLE_DECLARATION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getParameterSimpleParameterParserRuleCall_0_0(), semanticObject.getParameter());
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getExpressionGenericExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GenericExpression returns VariableExpression
	 *     VariableExpression returns VariableExpression
	 *
	 * Constraint:
	 *     variable=[Parameter|QualifiedName]
	 */
	protected void sequence_VariableExpression(ISerializationContext context, VariableExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimplejavaPackage.Literals.VARIABLE_EXPRESSION__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplejavaPackage.Literals.VARIABLE_EXPRESSION__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableExpressionAccess().getVariableParameterQualifiedNameParserRuleCall_0_1(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns WhileStatement
	 *     WhileStatement returns WhileStatement
	 *
	 * Constraint:
	 *     (condition=ParanthesisOrBinaryExpression body=Statement)
	 */
	protected void sequence_WhileStatement(ISerializationContext context, WhileStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimplejavaPackage.Literals.WHILE_STATEMENT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplejavaPackage.Literals.WHILE_STATEMENT__CONDITION));
			if (transientValues.isValueTransient(semanticObject, SimplejavaPackage.Literals.WHILE_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplejavaPackage.Literals.WHILE_STATEMENT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileStatementAccess().getConditionParanthesisOrBinaryExpressionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getWhileStatementAccess().getBodyStatementParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
}
